# Importing Blender Models into Bevy

This example shows how to import a 3D model made in Blender into Bevy. You can also use this for any 3D model in the form of a .glb file. For reference, I will use a donut model that i made in Blender.

In order for this to work, you need to have your Blender model exported as a .glb file. Simply click File > Export > glTF 2.0 (.glb/.gltf). Keep the default toggles and export the file, preferably to an assets folder located inside your project.

Bevy expects all runtime assets to be located inside the `assets/` folder at the root of your project. If your `.glb` file is placed elsewhere, it won’t be found by the asset loader.

> **Note:** The Bevy version used in this example is `0.15`.

## Set up the scene
Let's start off by creating an empty project and spawning the camera in the `setup()` function. We will also add lights so the scene is well lit and we can see our object more clearly. We rotate the camera so it faces the origin using the looking_at() function and enable shadows for a better view of the object's shape and texture.

``` rust
use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        .run();
}
fn setup(
    mut commands: Commands,
) {
    commands.spawn((
        Camera3d::default(),
        Transform::from_xyz(5.0, 5.0, 5.0).looking_at(Vec3::ZERO, Vec3::Y),
        GlobalTransform::default(),
    ));

    commands.spawn((
        PointLight {
            shadows_enabled: true,
            ..default()
        },
        Transform::from_xyz(4.0, 8.0, 4.0),
    ));
}
```

## Spawn Donut
Now that we've got the scene ready, let's spawn our donut along with the other entities in the setup() function.

```rust
commands.spawn((
    SceneBundle {
        scene: bevy::prelude::SceneRoot(asset_server.load("Donut.glb#Scene0")),
        transform: Transform::from_xyz(0.0, 0.0, 0.0),
        ..default()
    },
));
```

> **Note:** The `#Scene0` suffix refers to the first scene embedded in the `.glb` file. Blender exports one scene by default, and Bevy loads it using this identifier. If your model contains multiple scenes, you can reference them using `#Scene1`, `#Scene2`, and so on.

**How this works:**

- The `SceneBundle` creates a root entity.
- When the GLB scene (`Donut.glb#Scene0`) finishes loading, Bevy automatically spawns all the entities defined in that scene as children of the root entity.
- This means the donut model and all its parts become entities in our world, parented to the root entity we just spawned.

Now, if we run our code, we should see our Blender donut model appear in the Bevy scene, fully lit and ready to go.

> **Tip:** If your model appears too small or too large, try adjusting its scale in Blender before exporting. Alternatively, you can apply a scale transform in Bevy using `Transform::from_scale(...)` to resize it manually.

## Interactions

Now let's add some basic interaction to our scene to demonstrate that our donut model behaves just like any other 3D entity in Bevy. For example, we can create a function that detects when the donut is clicked and then prints something in the terminal to indicate the interaction.

```rust
fn check_donut_click(
    windows: Query<&Window, With<PrimaryWindow>>,
    cameras: Query<(&Camera, &GlobalTransform)>,
    mouse_button_input: Res<ButtonInput<MouseButton>>,
) {
    if mouse_button_input.just_pressed(MouseButton::Left) {
        let Ok(window) = windows.get_single() else { return; };
        let Some(cursor_pos) = window.cursor_position() else { return; };
        let Ok((camera, camera_transform)) = cameras.get_single() else { return; };
        let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_pos) else { return; };
        let donut_center = Vec3::ZERO; // assuming donut at origin
        let radius = 1.0; // adjust as needed
        let origin_to_center = donut_center - ray.origin;
        let tca = origin_to_center.dot(ray.direction.as_vec3());
        let d2 = origin_to_center.length_squared() - tca * tca;
        if d2 <= radius * radius {
            println!("Donut clicked!");
        }
    }
}
```

I know this looks like a lot so let's break it down.

```rust
let Ok(window) = windows.get_single() else { return; };
```
- Retrieves the active game window to access cursor position.
- Returns early if the window isn't found (e.g., during setup).

```rust
let Some(cursor_pos) = window.cursor_position() else { return; };
```
- Gets the cursor's position in window space.
- If the cursor isn’t inside the window, exit the function.

```rust
let Ok((camera, camera_transform)) = cameras.get_single() else { return; };
```
- Gets the camera used to render the scene and its world transformation.

```rust
let Ok(ray) = camera.viewport_to_world(camera_transform, cursor_pos) else { return; };
```
- Translates the 2D cursor position into a **3D ray** using the camera’s perspective.
- The ray can be used to check for intersections in 3D space.

```rust
let donut_center = Vec3::ZERO;
let radius = 1.0;
```
- Treats the donut as a simple sphere at the origin for hit detection.
- Realistically, you'd use a torus shape — but this keeps it simple.

```rust
let origin_to_center = donut_center - ray.origin;
```
- Calculates the vector from the ray origin to the donut center

```rust
let tca = origin_to_center.dot(ray.direction.as_vec3());
let d2 = origin_to_center.length_squared() - tca * tca;
```
- Calculates how close the ray comes to the donut center.
- If this squared distance is less than the squared radius...

```rust
if d2 <= radius * radius {
    println!("Donut clicked!");
}
```
- The ray intersects the sphere (donut), so the click is considered a hit.

This function checks for a left mouse click, casts a ray from the camera through the cursor’s position into 3D space, and determines whether it intersects the donut. If it does, we print a message demonstrating that the donut behaves like any other clickable entity in a Bevy scene. This approach treats the donut as a sphere for simplicity.

Let's run our code to see if it works. Hopefully, you should see a message printed in the terminal every time you click on the donut object.

## Troubleshooting

If your model doesn't appear in the scene:

- Make sure the `.glb` file is inside the `assets/` folder.
- Check that the file path in `asset_server.load("Donut.glb#Scene0")` matches the actual filename.
- Confirm that the camera is positioned to view the origin (`Vec3::ZERO`), where the model is spawned.
- Ensure the model was exported with geometry and materials included.

## Recap

In this example, we:

- Exported a `.glb` model from Blender
- Loaded it into Bevy using `SceneBundle`
- Positioned the camera and added lighting
- Used raycasting to detect clicks on the model
- Verified the setup with troubleshooting tips

---

**This is just a primitive example, showing how to import a 3D model from Blender into Bevy and demonstrating basic interaction using simple raycasting**. You can check out the full code [here](https://github.com/annazeit/blog/blob/main/bevy_blog_code/bevy_blender/src/main.rs). This method works for any `.glb` file, making it a reliable way to bring custom 3D assets into your Bevy projects.