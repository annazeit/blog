# How [Jiggle](https://github.com/annazeit/blog/blob/main/bevy_blog_code/jiggle_sphere/src/main.rs) works

The jiggle effect on the sphere is achieved through procedural animation, triggered by pressing **B** or clicking on the sphere. Here's how it works:

### **1. Activating the Jiggle**
- When **B** is pressed or the sphere is clicked, the `JiggleAnimation` component is activated (`active = true`), and a timer starts (`timer = 0.0`).
- The sphere will jiggle for **1.5 seconds**, as defined by `JIGGLE_DURATION`.

### **2. Calculating the Jiggle Motion**
- The animation follows a **sinusoidal movement**:
  - A **jiggle amplitude** (`1.0`) defines how far the sphere moves up and down.
  - A **jiggle speed** (`16.0`) controls how fast the movement oscillates.
  - The amplitude **decays over time**, meaning the jiggle starts strong and fades out.

### **3. Applying the Jiggle to the Sphere**
- Every frame, the vertical position (`transform.translation.y`) is updated using:
  \[
  \text{offset} = \sin(\text{timer} \times \text{jiggle speed}) \times \text{amplitude}
  \]
- The **amplitude decays quadratically** over time:
  \[
  \text{amplitude} = (\frac{\text{JIGGLE_DURATION} - \text{timer}}{\text{JIGGLE_DURATION}})^2
  \]
- When the timer reaches `JIGGLE_DURATION`, the jiggle stops and the sphere resets to its default position.

### **4. Jiggle on Click**
- A **raycast** is used to determine if the mouse clicked on the sphere.
- If the ray intersects with the sphere's **bounding radius**, the jiggle animation is triggered.

This results in a natural **bouncy movement** that quickly oscillates and then fades out smoothly. If you want a more exaggerated or prolonged effect, adjusting **amplitude, speed, or decay rate** can fine-tune the jiggle behavior. Let me know if you need tweaks! 


Thanks for sharing the explanation and the code, Anna! Based on your notes and the GitHub source, here’s a full article draft in the same style as your previous posts—clean, structured, and beginner-friendly.

---

# **Jiggle Sphere in Bevy**

This example demonstrates how to create a **procedural jiggle animation** in Bevy. The effect is triggered by pressing **B** or clicking on the sphere, causing it to bounce briefly before settling back into place.

> **Note:** The Bevy version used in this example is `0.15`.

---

## **1. Spawning the Scene**

We start by spawning a **3D camera**, a **light source**, a **grid**, and a **sphere**. The sphere is tagged with a `SphereTag` component and a `JiggleAnimation` component, which controls the jiggle behavior.

```rust
#[derive(Component)]
struct JiggleAnimation {
    active: bool,
    timer: f32,
}
```

The camera uses a `FlyCamera` component to allow free movement using keyboard input.

---

## **2. Triggering the Jiggle**

The jiggle animation can be triggered in two ways:

- **Pressing the B key**
- **Clicking on the sphere**

When triggered, the `JiggleAnimation` component is activated and its timer is reset:

```rust
if keys.just_pressed(KeyCode::KeyB) {
    jiggle.active = true;
    jiggle.timer = 0.0;
}
```

Clicking is handled via **raycasting** from the camera to the mouse cursor. If the ray intersects the sphere’s bounding radius, the jiggle is triggered.

---

## **3. Jiggle Motion**

The jiggle effect is a **sinusoidal vertical movement** that decays over time. Each frame, the sphere’s Y position is updated using:

```rust
let offset = (jiggle.timer * jiggle_speed).sin() * amplitude;
transform.translation.y = offset;
```

The amplitude decays **quadratically**:

```rust
let decay = ((JIGGLE_DURATION - jiggle.timer) / JIGGLE_DURATION).max(0.0);
let amplitude = jiggle_amplitude * decay * decay;
```

After `JIGGLE_DURATION` (1.5 seconds), the jiggle stops and the sphere resets to its original position.

---

## **4. Raycast Click Detection**

Clicking the sphere uses Bevy’s `viewport_to_world()` to convert the mouse position into a world-space ray. The ray is then tested against the sphere’s bounding radius:

```rust
let origin_to_center = center - ray.origin;
let tca = origin_to_center.dot(ray_direction);
let d2 = origin_to_center.length_squared() - tca * tca;

if d2 <= radius * radius {
    jiggle.active = true;
    jiggle.timer = 0.0;
}
```

This simple ray-sphere intersection test ensures accurate click detection.

---

## **Recap**

In this example, we:

- Spawned a sphere with a jiggle animation component
- Triggered the jiggle via keyboard and mouse input
- Used a sinusoidal function with quadratic decay for smooth motion
- Applied raycasting to detect clicks on the sphere

The result is a natural, bouncy animation that fades out smoothly. You can tweak the **amplitude**, **speed**, or **decay rate** to customize the effect.

Check out the full code on GitHub:  
[Jiggle Sphere Example](https://github.com/annazeit/blog/blob/main/bevy_blog_code/jiggle_sphere/src/main.rs)

---

Let me know if you want to add visuals, a challenge section, or expand this into a series on procedural animation!

